<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title></title>
	<link href="http://127.0.0.1/atom.xml" rel="self" />
	<link href="http://127.0.0.1/" />
	<updated>2017-06-11T21:20:15+08:00</updated>
	<id>http://127.0.0.1/</id>
	<author>
		<name>wilsonIsOnly</name>
		<email>zhuimengzhe91@163.com</email>
	</author>
	
	<entry>
		<title>Vue.js学习指南</title>
		<link href="http://127.0.0.1/blog/posts/vue2" />
		<updated>2017-01-10T00:00:00+08:00</updated>
		<id>http://127.0.0.1/blog/posts/vue2</id>
		<content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2>
<blockquote>
  <p>虽说<a href="https://vuefe.cn/v2/guide/">vue官网</a>已经有很详细的教程，而且我也是在这里边看边学习的。不过我是希望能够总结出一些对自己有用的部分，或者希望学习完之后能够理出自己的思路来，这样，也算是达到了我写笔记的目的。</p>
</blockquote>

<h2 id="目录结构">目录结构</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>1. 简介
2. 安装
3. 一个完整的Vue实例
4. vue实例的API
    4.1. vue属性-DOM与数据的方法
        4.1.1. vue属性-DOM
        4.1.2. vue属性-数据
        4.1.3. vue属性-其它
    4.2. vue实例-数据与钩子
        4.2.1. vue实例-数据
        4.2.2. vue实例-事件
        4.2.3. vue实例-生命周期回调函数
5. Vue的全局配置
6. Vue的全局API
7. Vue的指令
</code></pre>
</div>

<h2 id="1简介">1.简介</h2>

<p>Vue.js 集中在 MVVM 模式上的视图模型层，并通过双向数据绑定连接视图和模型。实际的 DOM 操作和输出格式被抽象出来成指令和过滤器。</p>

<p>Vue.js 的 API 参考了Angular,knockout,reat和rivets,建议对此4个框架做些了解。</p>

<h2 id="2安装">2.安装</h2>

<blockquote>
  <p>Vue.js不支持IE8及以下版本。</p>
</blockquote>

<p>小型应用：直接引入<a href="http://vuejs.org/js/vue.js">vue.js</a> <script src="vue.js"></script></p>

<p>大型应用：通过命令行 npm install vue 来安装</p>

<p>官方命令行工具：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#vue-cli即为官方提供的命令行工具，用于快速搭建大型单页应用
npm install --global vue-cli
#基于webpack模板创建一个项目
vue init webpack projectName
cd projectName
#安装依赖
npm install
#开发环境
npm run dev
#OR 生产环境
npm run build
</code></pre>
</div>

<h2 id="3一个完整的vue实例">3.一个完整的Vue实例</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>var vm = new Vue({
    el:'#app',  
    data:{      
        message:'hello world!' 
    },
    template:'',
    render:{
        //
    },
    propsData:{
        //
    },
    computed:{
        //
    },
    method:{
        //
    },
    watch:{
        //
    },
    
    //生命周期钩子-&gt;生命周期回调函数
    beforeCreate:{
        // 实例初始化之后，数据及事件配置之前
    },
    //-&gt;observe Data -&gt;init Events
    created:{
        //实例创建完成之后
    },
    //-&gt;compile template编译模板
    beforeMount:{
        //组件开始挂载到文档里之前，render首次被调用，服务端渲染不被调用
    },
    //-&gt;create vm.$el
    mounted:{
        //组件、vm.$el已经挂载到文档里
    },
    //-&gt; Mounted
    beforeUpdate:{
        //虚拟DOM重新渲染when data changes
    },
    //-&gt; 虚拟DOM节点重新渲染加载
    updated：{
        //页面更新好了
    },
    activated: {
        //keep-alive组件激活时
    },
    deactivated: {
        //keep-alive组件停用时
    },
    //-&gt; 当调用vm.$destroy()方法
    beforeDestroy:{
        //销毁实例之前，实例仍可用
    }
    //-&gt; 解绑/删除函数监听、观察函数和组件、子实例
    destroyed:{
        //销毁实例之后
    }
    
})

生命周期如下图所示：
</code></pre>
</div>

<p><img src="https://raw.githubusercontent.com/wilsonIs/cdn-image/master/md/vue-lifecycle.png" alt="image" /></p>

<h2 id="4-vue的api">4. vue的API</h2>

<h3 id="41-vue属性-dom与数据的方法">4.1. vue属性-DOM与数据的方法</h3>

<h4 id="411-vue属性-dom">4.1.1. vue属性-DOM</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>el: //实例中，选中'***'的元素为挂载目标，可通过vm.$mount()显式挂载

template: //字符串模板，该模板将替换挂载的元素，

render: //函数，字符串模板的替代方案
</code></pre>
</div>

<h4 id="412-vue属性-数据">4.1.2. vue属性-数据</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>data: //该实例下存储的数据，一般为对象
    
    但是，当定义一个组件时，则data为一个函数，用于创建多个实例，如
    var component = Vue.extend({
        data :function () {
            return {
                key : value
            }
        }
    })
    
props: //组件中，用于接收来自父组件的数据，可为数组或对象
    
    //作为数组-&gt; 接收数据
    Vue.component('my-component',{
        props: ['size ','message']
    })
    //作为对象-&gt; 提供校验
    Vue.component('my-component',{
        props:{
            size:Number, //检测数据类型
            message: {
                type: Number,
                default:0,
                required:true,
                validator:function (value) {
                    return value &gt;=0
                }
            }
        }
    })
    
propsData: //组件new创建的实例中

    //用于传递props的value
    var component = Vue.extend({
        props: ['msg'],
        template: '&lt;div&gt;&lt;/div&gt;'
    })
    var vm = new component({
        propsData: {
            msg: 'hello'
        }
    })
    
computed: //vue实例中-&gt;计算属性

    var vm = new Vue({
        data: { a: 1 },
        computed: {
            // 仅读取，值只须为函数
            aDouble: function () {
            return this.a * 2
            },
            // 读取和设置
            aPlus: {
              get: function () {
                return this.a + 1
              },
              set: function (v) {
                this.a = v - 1
              }
            }
        }
    })
    vm.aPlus   // -&gt; 2
    vm.aPlus = 3
    vm.a       // -&gt; 2
    vm.aDouble // -&gt; 4
    
methods:  //vue实例中，用户自定义的方法，函数

    var vm= new Vue({
        methods: {
            onClicked:function(){
              //  
            },
            onEvent:function(){
                
            }
        }
    })
    
watch: //vue实例中，同$watch，但为对象，可设置观察多个key

    var vm= new Vue({
        data: {
            a:1,
            b:2,
        },
        watch: {
            a: function (newVal, oldVal){
                //
            },
            b: function (newVal, oldVal){
                //
            }
        }
        
    }) 
</code></pre>
</div>

<h4 id="413-vue属性-其它">4.1.3. vue属性-其它</h4>
<div class="highlighter-rouge"><pre class="highlight"><code>directives: 

filters:

components:

parent:

mixins:

name: 

extends:

delimiters:

functional:
</code></pre>
</div>

<hr />

<h3 id="42-vue实例-数据与钩子">4.2. vue实例-数据与钩子</h3>

<h4 id="421-vue实例-数据">4.2.1. vue实例-数据</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>vm.$el 
    //-&gt;$("#app").get(0);
vm.$data 
    //-&gt;data
vm.$options 
    //-&gt;自定义vue实例属性
vm.$parent 
    //-&gt;父实例
vm.$root 
    //-&gt;当前组件树的根Vue实例，或自己
vm.$children
    //-&gt;当前实例的直接子组件
vm.$slots
    //-&gt;访问slot分发内容，如vm.$slots.foo
vm.$scopedSlots
    //-&gt;访问具名slot
vm.$refs
    //-&gt;对象，包含所有的引用信息(元素或子组件)
vm.$isServer
    //-&gt;Boolean,当前vue实例是否运行于服务器端
vm.$watch 
    //-&gt;监听data中值的变化,复杂的也可以监听一个计算属性函数
    var unwatch = vm.$watch('a',function(oldV,newV){
        //
    })
    unwatch();//取消观察函数
vm.$set
    //-&gt;等同于Vue.set,用于设置属性的key-value
vm.$delete
    //-&gt;等同于Vue.delete,用于删除属性值
</code></pre>
</div>

<h4 id="422-vue实例-事件">4.2.2. vue实例-事件</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>vm.$on
    //-&gt;用于监听自定义事件
vm.$once
    //-&gt;只触发一次，然后移除监听器
vm.$off
    //-&gt;移除监听器
    vm.$off() //移除所有的事件监听器
    vm.$off([event]) //移除该事件所有监听器
    vm.$off([callback]) //移除该回调函数的监听器
vm.$emit
    //-&gt;主动触发实例上事件,并可传递参数
    vm.$emit(event,[...args])
</code></pre>
</div>

<h4 id="423-vue实例-生命周期回调函数">4.2.3. vue实例-生命周期回调函数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>vm.$mount
    //-&gt;手动挂载需要关联的DOM元素,可链式调用
vm.$forceUpdate()
    //-&gt;强制Vue实例重新渲染
vm.$nextTick([callback])
    //-&gt;等同于Vue.nextTick,修改数据后使用，在DOM下次更新循环之后执行callback
vm.$destroy()
    //-&gt;触发实例的beforeDestroy和destroyed回调函数
</code></pre>
</div>

<h2 id="5-vue的全局配置">5. Vue的全局配置</h2>

<p>Vue的全局配置可在Vue.comfig对象中设置相关的属性：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Vue.config.silent = true
    //取消Vue所有的日志和警告

Vue.config.optionMergeStrategies.myOption = function (parent,child,vm){
    //并没啥卵用...
    //自定义选项混合策略
}

Vue.config.devtools = true
    //启用vue-devtools检查代码

Vue.config.errorHandler = function (err,vm){
    //组件渲染和观察期间捕获错误的处理函数
}

Vue.ignoredElements = [
    'my-component','another-component'
]
    //忽略Vue之外自定义的元素
    
Vue.config.keyCodes = {
    up: [38,87],
    mediaPlayPause: 179
}
    //自定义按键的名称
</code></pre>
</div>

<h2 id="6-vue的全局api">6. Vue的全局API</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>Vue.extend({})  //创建一个vue实例，传入组件对象，并挂载到一个元素上

    var Profile = Vue.extend({
        template:'&lt;p&gt;&lt;/p&gt;',
        dta: function () {  //此处必须为函数
            return {
                msg: 'hello'
            }
        }
    })
    new Profile().$mount('#profile');

Vue.nextTick() //修改数据后，在下次DOM更新循环结束后执行回调

Vue.set(object,key,value)  //用于设置对象的属性，可被检测到

Vue.delete(object,key)  //删除对象的属性

Vue.directive()  //注册或获取全局指令

Vue.filter()  //注册或获取全局过滤器

Vue.component()  //注册或获取全局组件

Vue.use(plugin)  //安装Vue.js插件

Vue.mixin()  // 全局注册一个混合对象,将被每一个Vue实例使用
    
    //比如定义一个混合对象
    var myMixin = {
        created: function () {
            //
        },
        methods: {
            //
        }
        
    }
    //该mixin被组件使用
    var Component = Vue.extend({
        mixins: [myMixin]
    })
    
Vue.compile(template)  //在render函数中编译模板字符串
</code></pre>
</div>

<h2 id="7-vue的指令">7. Vue的指令</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>v-text

v-html

v-show

v-if

v-else

v-else-if

v-for

v-on

v-bind

v-model:  //表单控件或组件上创建双向绑定

v-pre:  //跳过该元素及其子元素的编译，即不编译

v-cloak:  //隐藏直至编译完毕
    //配合css使用
    [v-cloak]{
        display: none;
    }
    &lt;div v-cloak&gt;
        
    &lt;/div&gt;
    
v-once:  //元素或组件上，只渲染一次，不发生重新渲染，用于优化更新性能。
</code></pre>
</div>

]]></content>
	</entry>
	
	<entry>
		<title>配置两个git账号</title>
		<link href="http://127.0.0.1/blog/posts/git-accounts-config" />
		<updated>2016-12-22T00:00:00+08:00</updated>
		<id>http://127.0.0.1/blog/posts/git-accounts-config</id>
		<content type="html"><![CDATA[<p>因为公司使用的是stash，而自己的博客使用的却是github，刚开始的时候配置好了gitub账号，发现公司的stash出错了，无法使用。发现两边共用的同一个config配置信息，里面的账号和邮箱只能有一个，也就是在C盘里存储的全局config配置。</p>

<p>但是如果在工作之余也想用公司的电脑来维护个人的博客，这个时候该怎么办？</p>

<p>在网上搜索了很多git多账号配置的文章，如下：</p>

<ul>
  <li><a href="https://segmentfault.com/a/1190000006105679">git多账号登录问题</a></li>
  <li><a href="https://segmentfault.com/a/1190000006105759">git多账号配置问题</a></li>
</ul>

<p>看了之后，觉得很有道理，这样配置应该没有问题，但是现实是。。。依然在提交的时候被deny了。。。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>不过研究了那么久，我发现我还是懒一点，只在博客的目录下设置局部账户配置信息，就可以搞定了，so .....

cd "进入博客根目录"
git config --local user.name "wilsonIs"
git config --local user.email "zhangtao522009@163.com"

当然ssh的配置在这之前已经设置好了。
</code></pre>
</div>

<p>能满足需求就好了，其它的多账号的配置以后有需要的时候再来分析吧。</p>

<p>对，现在是在用公司的电脑编辑，嗯，下班了。</p>
]]></content>
	</entry>
	
	<entry>
		<title>资源列表</title>
		<link href="http://127.0.0.1/blog/posts/resource" />
		<updated>2016-12-04T00:00:00+08:00</updated>
		<id>http://127.0.0.1/blog/posts/resource</id>
		<content type="html"><![CDATA[<p>写在前面：本文主要收集一些常用的外部资源。有好的资源欢迎留言推荐。</p>

<h3 id="htmlcssjs">HTML/CSS/JS</h3>

<ul>
  <li><a href="http://es6.ruanyifeng.com/">ES6入门</a></li>
  <li><a href="http://css.doyoe.com/">Css参考手册</a></li>
  <li><a href="https://developer.mozilla.org/zh-CN/">MDN-Mozilla开发者网络</a></li>
  <li><a href="http://www.w3school.com.cn/">W3C School</a></li>
</ul>

<h3 id="在线学习">在线学习</h3>
<ul>
  <li><a href="http://www.runoob.com/">菜鸟教程</a></li>
  <li><a href="http://www.imooc.com/">慕课网</a></li>
  <li><a href="http://www.jikexueyuan.com/">极客学院</a></li>
  <li><a href="https://isux.tencent.com/">腾讯ISUX</a></li>
  <li><a href="http://www.qdfuns.com/">前端网</a></li>
  <li><a href="https://www.coursera.org/">Coursera</a></li>
  <li><a href="https://cn.udacity.com/">优达学城</a></li>
</ul>

<h3 id="前端框架库">前端框架/库</h3>
<ul>
  <li><a href="http://www.bootcss.com/">Bootstrap中文网</a></li>
  <li><a href="http://www.requirejs.cn/">requirejs中文文档</a></li>
  <li><a href="http://www.css88.com/doc/backbone/">backbonejs中文文档</a></li>
  <li><a href="http://www.css88.com/doc/underscore/">underscorejs中文文档</a></li>
  <li><a href="http://seajs.org/docs/">seajs中文文档</a></li>
  <li><a href="https://vuefe.cn/">vue中文文档</a></li>
  <li><a href="http://www.apjs.net/">angularjs中文文档</a></li>
  <li><a href="http://nodejs.cn/">nodejs中文文档</a></li>
</ul>

<h3 id="前端工具库">前端工具库</h3>
<ul>
  <li><a href="www.iconfont.cn/">Iconfont</a></li>
  <li><a href="fontawesome.io">Fontawesome</a></li>
  <li><a href="http://fis.baidu.com/">Fis3</a></li>
  <li><a href="http://echarts.baidu.com/index.html">Echarts</a></li>
  <li><a href="spritepad.wearekiss.com/">spritepad</a></li>
  <li><a href="http://www.sojson.com/">json在线转换</a></li>
</ul>

<h3 id="牛人博客">牛人博客</h3>

<ul>
  <li><a href="http://www.ruanyifeng.com/blog/">阮一峰的网络日志</a></li>
  <li><a href="http://www.zhangxinxu.com/wordpress/">张鑫旭-鑫空间-鑫生活</a></li>
  <li><a href="http://www.cnblogs.com/rubylouvre/">司徒正美－Ruby’s Louvre</a></li>
  <li><a href="http://www.liaoxuefeng.com/">廖雪峰的官方网站</a></li>
</ul>

<h3 id="交流社区">交流社区</h3>
<ul>
  <li><a href="http://cn.v2ex.com/">V2EX</a></li>
  <li><a href="https://segmentfault.com/">Segmentfault</a></li>
  <li><a href="http://my.csdn.net/">CSDN</a></li>
  <li><a href="http://www.cnblogs.com/">博客园</a></li>
  <li><a href="http://www.jianshu.com/">简书</a></li>
  <li><a href="http://www.zhihu.com">知乎</a></li>
  <li><a href="https://gold.xitu.io/">掘金</a></li>
</ul>

<h3 id="开发者平台">开发者平台</h3>
<ul>
  <li><a href="https://github.com/wilsonIs">github</a></li>
  <li><a href="https://git.oschina.net/signup?inviter=wilsonis">码云－开源中国</a></li>
  <li><a href="http://www.sinacloud.com/">新浪云</a></li>
  <li><a href="https://mp.weixin.qq.com/">微信公众平台</a></li>
</ul>

<h3 id="搭建个人博客">搭建个人博客</h3>
<ul>
  <li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html">github pages+jekyll入门</a></li>
  <li><a href="https://github.com/jekyll/jekyll/wiki/Sites">github博客范例</a></li>
  <li><a href="http://www.appinn.com/markdown/">Markdown语法说明</a></li>
  <li><a href="http://cn.gravatar.com/">Gravatar - 全球公认的头像</a></li>
  <li><a href="http://tongji.baidu.com/">百度统计</a></li>
  <li><a href="http://zhanzhang.baidu.com/">百度站长平台</a></li>
  <li><a href="http://www.google.cn/intl/zh-CN_ALL/analytics/features/-tools.html">谷歌统计</a></li>
  <li><a href="https://www.growingio.com/">Growingio数据分析</a></li>
  <li><a href="https://www.dnspod.cn/Login">DNSPod域名解析</a></li>
  <li><a href="http://duoshuo.com/">多说评论系统</a></li>
  <li><a href="https://www.godaddy.com/">godadady域名购买</a></li>
  <li><a href="http://www.rongcloud.cn/">融云IM即时通讯</a></li>
</ul>

]]></content>
	</entry>
	
	<entry>
		<title>软件工程化:Jira + Stash + Bamboo + Confluence</title>
		<link href="http://127.0.0.1/blog/posts/software-dev-engineering" />
		<updated>2016-11-29T00:00:00+08:00</updated>
		<id>http://127.0.0.1/blog/posts/software-dev-engineering</id>
		<content type="html"><![CDATA[<p>八爪有一整套的研发管理系统，实现从代码管理到服务器搭建、问题追踪到编写开发文档，从而搭建起一整套开发流程的系统。以下是一些个人现阶段的理解。</p>

<p>** 使用的工具包括： **</p>

<h3 id="1-jira">1. Jira</h3>

<p>JIRA Software是优秀的敏捷项目工具，协助您追踪问题，集成代码，规划，开发，发布高质量的软件产品。</p>

<h3 id="2-stash">2. Stash</h3>

<p>Bitbucket(原名Stash)帮助团队创建和管理代码仓库，通过内联注释和变更讨论来使团队协同处理代码。</p>

<h3 id="3-confluence">3. Confluence</h3>

<p>Confluence将团队成员紧密的团结在一起，带领团队同心协力地在线编写文档，使团队成员工作更有效率。</p>

<h3 id="4-bamboo">4. Bamboo</h3>

<p>Bamboo运行在各种专用服务器或云服务器上的代理实现了构建能力的即时动态扩展。</p>
]]></content>
	</entry>
	
	<entry>
		<title>一个合格前端工程师应该掌握的知识技能</title>
		<link href="http://127.0.0.1/blog/posts/front-end-should-know" />
		<updated>2016-11-17T00:00:00+08:00</updated>
		<id>http://127.0.0.1/blog/posts/front-end-should-know</id>
		<content type="html"><![CDATA[<p>前段时间在<a href="https://github.com/JacksonTian/fks">朴灵</a>的github中，看到了一张出自<a href="https://github.com/jayli">拔赤</a>之手的前端工程师技能树，有感原来前端的技能树如此的丰富，而自己所知所会的竟然如此之少，实在是大开眼界。遂保存起来希望以后能慢慢的点满前端技能树。</p>

<p>今天有幸认识了拓维云校园的杰哥，点出了自己基础薄弱的地方以及作为前端人员应有的追求。认识到自己实在是应该立即面对自己的不足，从基础抓起，逐步完善自己的知识体系，早日成为一名合格的前端工程师。</p>

<p><strong>前端工程师技能树如下所示：</strong></p>

<p><img src="http://www.wilsonisonly.com/works/img/FrontEnd.jpg" alt="" /></p>

]]></content>
	</entry>
	
	<entry>
		<title>常用跨域方法总结</title>
		<link href="http://127.0.0.1/blog/posts/cross-domain" />
		<updated>2016-11-15T00:00:00+08:00</updated>
		<id>http://127.0.0.1/blog/posts/cross-domain</id>
		<content type="html"><![CDATA[<h3 id="1-什么是跨域">1. 什么是跨域</h3>

<p>同源：相同protocal, domain, port的情况下，则为同源.</p>

<p>在非同源的情况下，则需要考虑跨域。</p>

<h3 id="2-常用跨域方法">2. 常用跨域方法</h3>

<p><strong>1) 服务器端设置跨域</strong></p>

<p>nodejs的service.js中设置：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>app.all('*',function(req,res,next){
	res.header("Access-Control-Allow-Origin","*");   //接受任意域名的请求
	res.header("Access-Control-Allow-Header","X-Requested-With");
		//额外发送的头信息字段，用以区分传统请求和ajax请求
	res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS");
		//允许的请求方式
	res.header("Content-Type","application/json;charset=utf-8");
		//请求的数据类型
})
</code></pre>
</div>

<p><strong>2) JSONP跨域</strong></p>

<p>通过script标签设置回调函数来实现，如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;script src = 'http://www.baidu.com/json/?callback=handleResponse'&gt;&lt;/script&gt;
</code></pre>
</div>

<p><strong>3) H5 API postMessage跨域</strong></p>

<p>a.com/index.html的设置:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;iframe id="ifr" src="b.com/index.html"&gt;&lt;/iframe&gt;
&lt;script type="text/javascript"&gt;
	window.onload = function() {
		var ifr = document.getElementById('ifr');
		var targetOrigin = 'http://b.com';
			// 若写成'http://b.com/c/proxy.html'效果一样
           // 若写成'http://c.com'就不会执行postMessage了
		ifr.contentWindow.postMessage('I was there!', targetOrigin);
	};
&lt;/script&gt;
</code></pre>
</div>

<p>b.com/index.html的设置:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;script type="text/javascript"&gt;
   		 window.addEventListener('message', function(event){
 		   // 通过origin属性判断消息来源地址
  		  if (event.origin == 'http://a.com') {
     		 alert(event.data);    // 弹出"I was there!"
       		 alert(event.source);
				// 对a.com、index.html中window对象的引用
                // 但由于同源策略，这里event.source不可以访问window对象
		    }
   		 }, false);
&lt;/script&gt;
</code></pre>
</div>

<p><strong>4)Web Socket实现跨域</strong></p>

<p>web sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)。</p>

<p>web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。</p>

<p>只有在支持web socket协议的服务器上才能正常工作。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var socket = new WebSockt('ws://www.baidu.com');//http-&gt;ws; https-&gt;wss
socket.send('hello WebSockt');
socket.onmessage = function(event){
	var data = event.data;
}
</code></pre>
</div>

<h3 id="3-其它不常用的跨域方法">3. 其它不常用的跨域方法</h3>

<p><strong>1)document.domain + iframe      (只有在主域相同的时候才能使用该方法)</strong></p>

<p><strong>2)location.hash + iframe</strong></p>

<p><strong>3)window.name + iframe</strong></p>

<p>详细见<a href="http://blog.csdn.net/joyhen/article/details/21631833">前端解决跨域问题的8种方案</a></p>

]]></content>
	</entry>
	
	<entry>
		<title>前端自动化构建环境的搭建-淘宝UED团队</title>
		<link href="http://127.0.0.1/blog/posts/automatic-front-end-e" />
		<updated>2016-11-12T00:00:00+08:00</updated>
		<id>http://127.0.0.1/blog/posts/automatic-front-end-e</id>
		<content type="html"><![CDATA[<p>为了UED前端团队更好的协作开发同时提高项目编码质量，我们需要将Web前端使用工程化方式构建；</p>

<p>目前需要一些简单的功能：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	1. 版本控制
	6. 编译SASS
	2. 检查JS
	3. 图片合并
	4. 压缩CSS
	5. 压缩JS
</code></pre>
</div>

<p>这些都是每个Web项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。</p>

<p>目前最知名的构建工具： Gulp、Grunt、NPM + Webpack；</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	grunt是前端工程化的先驱

	gulp更自然基于流的方式连接任务

	Webpack最年轻，擅长用于依赖管理，配置稍较复杂

	推荐使用Gulp，Gulp基于nodejs中stream，效率更好语法更自然,不需要编写复杂的配置文件
</code></pre>
</div>

<h3 id="use-gulp-to-automate-front-end-build-tasks">Use Gulp to automate front-end build tasks</h3>

<p>Gulp是基于 Node.js的，需要要安装 Node.js</p>

<p>1、为了确保依赖环境正确，我们先执行几个简单的命令检查。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	node -v
	Node是一个基于Chrome JavaScript V8引擎建立的一个解释器
	检测Node是否已经安装，如果正确安装的话你会看到所安装的Node的版本号
</code></pre>
</div>

<p>2、接下来看看npm，它是 node 的包管理工具，可以利用它安装 gulp 所需的包</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	npm -v
	这同样能得到npm的版本号，装 Node 时已经自动安装了npm
</code></pre>
</div>

<p>3、开始安装Gulp</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	npm install -g gulp
	全局安装 gulp

	gulp -v
	得到gulp的版本号，确认安装成功
</code></pre>
</div>

<h2 id="基础安装结束">基础安装结束</h2>

<p>4、切换到你的在项目根文件夹下，运行</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	npm install gulp --save-dev //将具体的gulp功能插件局部安装项目下
</code></pre>
</div>

<p>5、安装gulp功能插件依赖包</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename--save-dev
</code></pre>
</div>

<blockquote>
  <p>gulp功能模块的文件会放在项目所在的目录的./node_modules 下</p>
</blockquote>

<p>6、我们目前先使用一些简单的功能：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    - 检查Javascript
    - 编译Sass文件
    - 合并Javascript
    - 压缩合并并重命名Javascript
</code></pre>
</div>

<blockquote>
  <p>新建gulpfile.js 配置文件放在项目根目录下</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code> 演示项目目录结构
	testProject		(项目名称)
	|–.git 			通过git进行版本控制,项目自动生成这个文件
	|–node_modules 	组件包目录
	|–dist 			**发布环境**（编译自动生成的）
	    |–css 		样式文件(style.css style.min.css)
	    |–images 	图片文件(压缩图片\合并后的图片)
	    |–js 		js文件(main.js main.min.js)
	    |–index.html  静态页面文件(压缩html)
	|–src 			**开发环境**
	    |–sass            	sass文件
	    |–images       		图片文件
	    |–js              	js文件
	    |–index.html 		静态文件
	|–gulpfile.js  			gulp配置文件
	|–package.json 			依赖模块json文件,在项目目录下npm install会安装项目所有的依赖模块，简化项目的安装程序
</code></pre>
</div>

<blockquote>
  <p>现在，项目文件夹都建好，组件也安装完毕了，我们需要编写gulpfile.js文件以指定gulp需要为我们完成什么任务。</p>
</blockquote>

<div class="highlighter-rouge"><pre class="highlight"><code>	gulpfile.js内容如下：

	// 引入gulp
	var gulp = require('gulp');

	// 引入组件
	var jshint = require('gulp-jshint');//检查js
	var sass   = require('gulp-sass');	//编译Sass
	var concat = require('gulp-concat');//合并
	var uglify = require('gulp-uglify');//uglify 组件（用于压缩 JS）
	var rename = require('gulp-rename');//重命名

	// 检查js脚本的任务
	gulp.task('lint', function() {
	    gulp.src('./js/*.js') //可配置你需要检查脚本的具体名字。
	        .pipe(jshint())
	        .pipe(jshint.reporter('default'));
	});

	// 编译Sass
	gulp.task('sass', function() {
	    gulp.src('./scss/*.scss')
	        .pipe(sass())
	        .pipe(gulp.dest('./css'));//dest()写入文件
	});

	// 合并，压缩js文件
	// 找到 js/ 目录下的所有 js 文件，压缩，重命名，最后将处理完成的js存放在 dist/js/ 目录下
	gulp.task('scripts', function() {
	    gulp.src('./js/*.js')
	        .pipe(concat('all.js'))
	        .pipe(gulp.dest('./dist'))
	        .pipe(rename('all.min.js'))
	        .pipe(uglify())
	        .pipe(gulp.dest('./dist'));

	        console.log('gulp task is done');//自定义提醒信息
	});

	.... // 其他任务类似

	// 定义默认任务,执行gulp会自动执行的任务
	gulp.task('default', function(){
	    gulp.run('lint', 'sass', 'scripts');

	    // 监听js文件变化，当文件发生变化后会自动执行任务
	    gulp.watch('./js/*.js', function(){
	        gulp.run('lint','scripts');
	    });
	});
</code></pre>
</div>

<p>7、现在，回到命令行窗口，可以直接运行gulp任务了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	gulp

	这将执行定义的default任务，就和以下的命令式同一个意思

	gulp default

	当然，我们可以运行在gulpfile.js中定义的任意任务，比如，现在单独运行sass任务：

	gulp sass
</code></pre>
</div>

<p>8、编译会显示Finished,如果你的JS有什么不好的地方它会提醒，避免一些不必要的错误，十分贴心</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	常见提醒：
	1.禁止在同一行声明多个变量。
	2.请使用 ===/!==来比较true/false或者数值
	3.使用对象字面量替代new Array这种形式
	4.不要使用全局函数。
	5.Switch语句必须带有default分支
	6.函数不应该有时候有返回值，有时候没有返回值。
	7.For循环必须使用大括号
	8.If语句必须使用大括号
	9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。
</code></pre>
</div>

<p>9、gulp的插件数量很多，后面还可以根据自己的需要进行添加任务</p>

<div class="highlighter-rouge"><pre class="highlight"><code>	常用的gulp插件参考
	gulp-imagemin: 		压缩图片
	gulp-ruby-sass: 	支持sass，安装此版本需要安装ruby
	gulp-minify-css: 	压缩css
	gulp-jshint:      	检查js
	gulp-uglify:      	压缩js
	gulp-concat:    	合并文件
	gulp-rename:  		重命名文件
	gulp-htmlmin: 		压缩html
	gulp-clean:      	清空文件夹
	gulp-livereload: 	服务器控制客户端同步刷新（需配合chrome插件LiveReload及tiny-lr）
</code></pre>
</div>

<h3 id="use-git-as-a-project-management-tool">Use Git as a project management tool</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>安装git， 下载安装包会安装好 Git Shell 和可视化环境

	http://git-scm.com/download/win

配置用户名：

	git config --global user.name "Your Name"
	git config --global user.email "email@example.com"

关联一个到团队的库

	git remote add origin git@github.com:markyun/My-blog.git

添加文件到仓库，添加全部文件用 . 表示

	git add .

把文件提交到仓库

	git commit -m " first add project file"

提交文件到团队仓库

	git push -u origin master //将本地的项目提交到远程仓库中。
</code></pre>
</div>

<p>以上就完成了前端团队最基本的开发环境搭建和代码提交工作流程。</p>

<p>补充：ZSmart UED Team 的前端开发软件环境 (Windows, Linux, Mac OS X)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>    安装Node.Js、NPM、Ruby、Java 基础环境
	Sublime Text3 + 插件 		  用于编写前端代码
	Google chrome 、Mozilla Firefox + Firebug
	Internet Explorer 			进行兼容测试和预览页面UI、动画效果和交互功能
	Node.js+Gulp 				进行前端自动化构建、JS语法验证、CSS压缩，图片压缩等；
	Koala 						实时编译Less、Sass、Compass、CoffeeScript;
	Github 						存储自己的代码库 、git或SVN用于版本控制和团队Code Review
	Tomcat、DedeAMPZ、MAMP	  进行简单运行环境演示
	Photoshop CC 切图 + Sprites 合并小图标
	XMind 						画出清晰的工作或业务逻辑思维图
</code></pre>
</div>
]]></content>
	</entry>
	
	<entry>
		<title>ES6知识点(三)</title>
		<link href="http://127.0.0.1/blog/posts/es6_3" />
		<updated>2016-11-09T00:00:00+08:00</updated>
		<id>http://127.0.0.1/blog/posts/es6_3</id>
		<content type="html"><![CDATA[<h3 id="七新增原始数据类型symbol">七、新增原始数据类型Symbol</h3>

<p>ES6中引入了一种新的原始数据类型Symbol，表示独一无二的值，它是javascript语言的第七种数据类型。其它六种分别是Undefined,Null,Boolean,String,Number,Object.</p>

<h3 id="1-symbol的意义">1. Symbol的意义</h3>

<p>Symbol的作用是保证每一个对象的属性名都是独一无二的，从根本上防止属性名的冲突。</p>

<p>Symbol值通过Symbol函数生成，凡是属性名属于Symbol类型的，都是独一无二的。Symbol通过Symbol函数生成，但不能使用new命令生成，因为生成的Symbol是一个原始类型的值，不是对象。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>let s = Symbol();

typeof s; //"symbol"
</code></pre>
</div>

<p>也就是说，ES6中对象的属性名可以有两种类型，一种是原先的字符串形式，另一种就是新增的Symbol类型。Symbol函数可以传入一个字符串参数，表示对该Symbol实例的描述，以示区分不同的实例。</p>

<p>Symbol值不能参与计算，不能进行字符串拼接，但可以通过调用toString方法显示转为字符串，除此之外，Symbol值只可以转为布尔值。</p>

<h3 id="2-symbol的使用">2. Symbol的使用</h3>

<p>Symbol作为属性名的使用方法有如下三种：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var mySymbol = Symbol();

// 第一种写法
var a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
var a = {
  [mySymbol]: 'Hello!'
};

// 第三种写法
var a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol] // "Hello!"
</code></pre>
</div>

<p>Symbol值作为对象属性名时，不能使用点运算符，只能放在方括号中。</p>

<h3 id="3-symbol的遍历">3. Symbol的遍历</h3>

<p>Symbol作为属性名，不会出现在for…in,for…of遍历中，但可以通过Object.getOwnPropertySymbols方法来获取制定对象的Symbol属性名，返回的是包含所有Symbol值的数组。</p>

<h3 id="4-symbol的内置方法">4. Symbol的内置方法</h3>

<p>Symbol有11种内置方法，这里不一一讲述了，啥时候能用到了再叙述。</p>

<h2 id="八set和map数据结构">八、Set和Map数据结构</h2>

<p>Set数据结构类似于数组，它的成员的值都是唯一的，没有重复值，Set本身是一个构造函数，用来生成数据结构。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var s = new Set();

[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));

for (let i of s) {
  console.log(i);
}
// 2 3 5 4
</code></pre>
</div>

<h3 id="1-set的属性和方法">1. Set的属性和方法</h3>

<p>Set结构的实例有以下属性。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Set.prototype.constructor：构造函数，默认就是Set函数。
Set.prototype.size：返回Set实例的成员总数。
</code></pre>
</div>

<p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>add(value)：添加某个值，返回Set结构本身。
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
has(value)：返回一个布尔值，表示该值是否为Set的成员。
clear()：清除所有成员，没有返回值。
</code></pre>
</div>

<p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>keys()：返回键名的遍历器
values()：返回键值的遍历器
entries()：返回键值对的遍历器
forEach()：使用回调函数遍历每个成员
</code></pre>
</div>

<h3 id="2-map数据结构">2. Map数据结构</h3>

<p>Map结构的键不限于字符串，各种类型的值都可以当做键。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>var m = new Map([
  [true, 'foo'],
  ['true', 'bar']
]);

m.get(true) // 'foo'
m.get('true') // 'bar'
</code></pre>
</div>

<p>Map结构的实例有以下属性和操作方法。</p>

<p><strong>属性：</strong></p>

<ul>
  <li>
    <p>size属性返回Map结构的成员总数。</p>
  </li>
  <li>
    <p>set(key, value)：set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。set方法返回的是Map本身，因此可以采用链式写法。</p>
  </li>
  <li>
    <p>get(key)：get方法读取key对应的键值，如果找不到key，返回undefined。</p>
  </li>
  <li>
    <p>has(key)：has方法返回一个布尔值，表示某个键是否在Map数据结构中。</p>
  </li>
  <li>
    <p>delete(key)：delete方法删除某个键，返回true。如果删除失败，返回false。</p>
  </li>
  <li>
    <p>clear()：clear方法清除所有成员，没有返回值。</p>
  </li>
</ul>

<p><strong>遍历方法</strong></p>

<p>Map原生提供三个遍历器生成函数和一个遍历方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历Map的所有成员。
</code></pre>
</div>
]]></content>
	</entry>
	
	<entry>
		<title>前端性能测试工具介绍</title>
		<link href="http://127.0.0.1/blog/posts/web-performance2" />
		<updated>2016-11-07T00:00:00+08:00</updated>
		<id>http://127.0.0.1/blog/posts/web-performance2</id>
		<content type="html"><![CDATA[<p>本文重点讲解WebPagetest的使用方法，其它工具略提一二。</p>

<p>测试网站以<a href="http://shein.com">国内最大的跨境电商平台shein</a>为例。</p>

<h3 id="1-雅虎yslow">1. 雅虎Yslow</h3>

<p>下载地址：<a href="http://yslow.org/">雅虎Yslow</a>，选择对应的浏览器下载安装插件使用。重启浏览器，按F12，在Firebug中可以看到安装好的Yslow,点击Run Test，可以得到分析后的结果。</p>

<h3 id="2-谷歌page-speed">2. 谷歌page speed</h3>

<p>下载地址：<a href="http://developers.google.com/speed/pagespeed/insights_extensions">谷歌pageSpeed</a>【<strong>Not recomended</strong>】</p>

<p>前面的一篇文章<a href="https://wilsonis.github.io/myblog//blog/posts/shein-performance-analysis">Chrome WebInspector对网页前端性能的简单的分析</a>也对Chorme自带的分析工具的使用进行了简单的介绍，有兴趣的同学可以看看。</p>

<h3 id="3-showslow">3. showslow</h3>

<p>测试地址：<a href="http://www.showslow.com">showslow</a>,在线测试web应用。</p>

<h3 id="4-httpwatch和dynatraces-ajax">4. HttpWatch和DynaTrace’s Ajax</h3>

<p>据说还有这两个测试工具,不过我不熟,有机会找来试试。</p>

<h3 id="5-webpagetest">5. WebPagetest</h3>

<p>测试地址：<a href="http://webpagetest.org/">WebPagetest</a>,在线测试web应用。</p>

<p>直接输入需要测试的网页，点击run test，等待一段时间后，就能得到测试结果。</p>

<p>下面是测试结果中一些不是很好理解的词汇进行了说明：</p>

<p><strong>First View: 第一次无缓存打开页面<br /></strong></p>

<p>This is the view of the page for someone who has never been to the Lonely Planet site before (or has cleared their cache since their last visit).</p>

<p><strong>Repeat View:只访问过一次的页面，重新再打开该页面<br /></strong></p>

<p>This is the view of a page if a user goes only to the page, closes their browser,and then reopens the browser and goes only to that page again as the first page they hit on the site.</p>

<p><strong>Flow View:之前至少访问过一次其它页面<br /></strong></p>

<p>This is the view of the page when a customer has previously visited at least one other Lonely Planet page.</p>

<h4 id="31-测试结果分析">3.1. 测试结果分析</h4>

<p>我们直接来看web page test给出的性能测试结果，因截图较长，放在文末。</p>

<p>截图中，右上角是页面速率指标，使用的是Yslow的字母分级格式。可以看到第五项Cache static content给出了很低的F级，在下方的清单列表中也给出了一系列的红X，表示这一块做得并不好。</p>

<p>继续往下看测试结果，在Detail部分，则指出了不同的速率指标的合格度，并详细地指出了所有可以改进的地方。截图中用红框框住的部分是特别需要进行优化的地方。非常的详细，对于网站开发人员来说，是非常有用的。</p>

<h4 id="32-针对性的优化手段">3.2. 针对性的优化手段</h4>

<h5 id="use-progressive-jpegs">Use Progressive JPEGs</h5>

<p>使用递增式编码来存储JPEG文件的好处可以从两个角度来说明：</p>

<ul>
  <li>
    <p>用户体验</p>

    <p>一个以progressive方式编码的jpeg文件，在浏览器上的渲染方式是由模糊到清晰的。用户能在渐变的图像当中获得所需信息的反馈。如果内容不是用户所期待的，用户就能提前前往新的页面。</p>
  </li>
  <li>
    <p>文件大小</p>

    <p>有实验证明，在JPEG文件小于10KB的时候，使用标准型编码（Huffman表已经被优化）的JPEG文件要小于使用渐变式编码的JPEG文件（发生概率为75%）。当文件大于10KB时，渐变式编码的JPEG文件有94%的概率拥有比标准编码的文件更小的体积。</p>
  </li>
  <li>
    <p>使用方法</p>

    <p>photoshop中图片save for web，勾选progressive。
  也可以使用工具jpegtran（72KB）。基于命令行操作，参数在程序内都有说明，一个典型的命令行是这样的：jpegtran -copy none -progressive source.jpg result.jpg。</p>
  </li>
</ul>

<h5 id="压缩工具">压缩工具</h5>

<ul>
  <li>
    <p>gzip,通过命令行压缩文件，压缩率在3至10倍，能显著降低加载文件的大小。</p>
  </li>
  <li>
    <p><a href="http://code.google.com/p/minify">Minify</a>,下载该文件，并解压到网站根目录下，打开Minify的控制面板，添加需要缩减的js文件，页面就生成了可链接到js文件缩减后的脚本标签。</p>
  </li>
  <li>
    <p><a href="http://yuilibrary.com/download/yuicompressor/">YUI Compressor</a>,下载该jar文件,以命令行的形式运行：</p>

    <p><code class="highlighter-rouge">java -jar yuicompressor-[version].jar [options] [file name]</code></p>
  </li>
  <li>
    <p><a href="https://developers.google.com/closure/compiler/">Closure Compiler</a>,它执行的是焦土优化策略，重写变量名，删除没用的函数,压缩效果显著，但压缩后的代码不具备可读性。</p>
  </li>
</ul>

<h5 id="设置缓存过期头">设置缓存过期头</h5>

<ul>
  <li>
    <p>expires:</p>

    <p>指定缓存到期GMT的绝对时间，如果设了max-age，max-age就会覆盖expires。如果expires到期需要重新请求。设expires的目的就是让没有更新的资源不应该产生http请求，如果强制产生请求则返回304，减少服务器压力和降低带宽。exprires属于服务器优化范畴，需要修改服务器配置并重启。</p>
  </li>
  <li>
    <p>max-age:</p>

    <p>指定缓存过期的相对时间秒数，max-ag=0或者是负值，浏览器会在对应的缓存中把Expires设置为1970-01-01 08:00:00 。</p>
  </li>
</ul>

<h4 id="33-sheincom测试结果">3.3. shein.com测试结果</h4>

<p><img src="http://i.imgur.com/DzrMpH2.jpg" alt="shein测试结果" /></p>

]]></content>
	</entry>
	
	<entry>
		<title>Chrome WebInspector对网页前端性能的简单的分析</title>
		<link href="http://127.0.0.1/blog/posts/shein-performance-analysis" />
		<updated>2016-11-05T00:00:00+08:00</updated>
		<id>http://127.0.0.1/blog/posts/shein-performance-analysis</id>
		<content type="html"><![CDATA[<h3 id="对shein网站前端性能的简单分析">对shein网站前端性能的简单分析</h3>

<p><img src="http://i.imgur.com/aSKa54u.png" alt="" /></p>

<h2 id="一-首页">一、	<a href="http://www.shein.com/">首页</a></h2>

<h3 id="1-chorme-timeline分析">1.	Chorme Timeline分析</h3>

<p>根据上图，将分析的时间段控制在打开页面的5S中以内，如下图可以看到，首页的性能还是不错的，包括HTML解析、JS执行、渲染和重绘的总事件为1894ms，也就是说在2S以内完成了能够自由浏览页面所需要的动作。主要消耗的时间在js执行部分，包括加载图片和js文件以及js的执行，即下图中的黄色和灰色块，总耗时1407ms，占比74%。</p>

<p><img src="http://i.imgur.com/XBZdPq1.png" alt="" /></p>

<h3 id="2-chrome-webinspector分析results">2.	Chrome WebInspector分析results</h3>

<p>下图是Chrome WebInspector自动检测出来的可以进行性能优化的部分，主要包括：</p>

<ul>
  <li>多个js、css文件的合并</li>
  <li>利用浏览器缓存图片</li>
  <li>css文件提前到js文件前面</li>
  <li>将CSS放在head中</li>
  <li>优化CSS代码</li>
</ul>

<p><img src="http://i.imgur.com/bJgcKGq.png" alt="" /></p>

<h2 id="二-whats-new页面">二、	<a href="http://www.shein.com/daily-new.html?icn=what%27snew&amp;ici=www_navbar01">What’s New页面</a></h2>

<h3 id="1-chrome-timeline分析">1.	Chrome Timeline分析</h3>

<p>选取what’s new页面的原因是该页面需要加载大量的图片，对于电商类网站具有一定的典型性。
然后选取页面打开到页面可以自由浏览的时间段进行分析，如图1选取时间段长6.46s，非空闲时间3.17s，其中js执行+other耗时2.10s，占比66.25%。加载图片和js文件是主要的耗时原因。</p>

<p>从图2和图3可以看出，加载了大量的图片，究其原因是没有使用懒加载/滚动加载技术，打开页面一次性加载了所有图片造成的。这对于电商类网站是至关重要的，国内任意大型电商网站都一定使用了懒加载/滚动加载技术，否则大量图片请求容易造成页面的卡顿，浏览不畅等。</p>

<p><a href="https://wilsonis.github.io/myblog//blog/posts/lazyload">懒加载</a>以及其他<a href="https://wilsonis.github.io/myblog//blog/posts/performance-optimazition">前端性能优化的最佳实践</a>点击链接查看。</p>

<p><img src="http://i.imgur.com/2m5ywUQ.png" alt="图1" /></p>

<p><img src="http://i.imgur.com/PRK8oRn.png" alt="图2" /></p>

<p><img src="http://i.imgur.com/6vFULOk.png" alt="图3" /></p>

<h3 id="2-chrome-webinspector分析results-1">2.	Chrome WebInspector分析results</h3>

<p>WebInspector对该页面的优化推荐与首页类似，这里就不做分析了。</p>

<p><img src="http://i.imgur.com/YDUfZ6d.png" alt="" /></p>

]]></content>
	</entry>
	
</feed>